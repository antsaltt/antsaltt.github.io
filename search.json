[{"title":"Top k问题 （快速选择&堆）","url":"/2025/05/03/Top%20k%E9%97%AE%E9%A2%98%20%EF%BC%88%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9&%E5%A0%86%EF%BC%89/","content":"快速排序思想（Quick Sort）\n选择一个“基准值”（pivot）。\n\n将数组划分为两部分：左边小于等于 pivot，右边大于 pivot。\n\n对左右两边递归地继续进行快速排序。\n\n\nvoid quickSort(vector&lt;int&gt;&amp; nums, int left, int right) &#123;    if (left &gt;= right) return;    int pivot = nums[right];    int i = left - 1;    for (int j = left; j &lt; right; ++j) &#123;        if (nums[j] &lt;= pivot) &#123;            ++i;            swap(nums[i], nums[j]);        &#125;    &#125;    swap(nums[i + 1], nums[right]); // 把 pivot 放到中间    quickSort(nums, left, i);    quickSort(nums, i + 2, right);&#125;\n\n快速选择思想（Quick Select）快排的核心思想在于递归的partition操作，通过一次partition操作可以保证pivot左边的元素小于于pivot，右边的元素大于pivot。在查找第 k 小（或第 k 大）元素问题中，partition与快速排序相似，但只递归一边。\nint partition(vector&lt;int&gt;&amp; nums, int left, int right) &#123;    int pivot = nums[right];           // 选取最后一个元素作为“基准”    int i = left;                      // i 表示 &lt;= pivot 的区域的右边界    for (int j = left; j &lt; right; ++j) &#123;        if (nums[j] &gt;= pivot) &#123;        // 保证左边是“大于等于 pivot”的数（因为我们找第 k 大）            swap(nums[i], nums[j]);    // 把当前 nums[j] 交换到 &lt;= pivot 区域的末尾            ++i;                       // 扩大该区域        &#125;    &#125;    swap(nums[i], nums[right]);        // 把 pivot 放到中间的位置（即第 i 位）    return i;                          // 返回 pivot 的最终位置&#125;int quickSelect(vector&lt;int&gt;&amp; nums, int left, int right, int k) &#123;    if (left &lt;= right) &#123;        int pos = partition(nums, left, right);  // 得到 pivot 的最终位置        if (pos == k) return nums[pos];          // 找到第 k 大的数（从 0 开始）        else if (pos &lt; k) return quickSelect(nums, pos + 1, right, k);  // 去右边找        else return quickSelect(nums, left, pos - 1, k);                // 去左边找    &#125;    return -1;  &#125;\n\nLeetCode 215.数组中第k大的元素给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。\n请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。\n你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。\nclass Solution &#123;public:    int partition(vector&lt;int&gt;&amp;nums, int left,int right)&#123;        int pivot = nums[right];        int i = left; //左边区域的右边界        // 把大于pivot的数放到左边        for(int j=left;j&lt;right;j++)&#123;            if(nums[j]&gt;=pivot)&#123;                swap(nums[i],nums[j]);//把nums[j]放到pivot左边的区域                i++;            &#125;        &#125;        swap(nums[i],nums[right]); // 把pivot放到中间的位置        return i;    &#125;    int quickSelect(vector&lt;int&gt;&amp;nums,int left,int right,int k)&#123;        if(left&lt;=right)&#123;            int pos = partition(nums,left,right);            if(pos == k) return nums[pos];            else if(pos&lt;k) return quickSelect(nums,pos+1,right,k);            else return quickSelect(nums,left,pos-1,k);        &#125;        return 0;    &#125;        int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;        int n = nums.size();        return quickSelect(nums,0,n-1,k-1);// 第k大元素的下标是k-1    &#125;&#125;;\n\n问题：超时。最坏情况下，时间复杂度到达O(n2)，输入的数组具有以下特征：\n\n非常长（几百个元素甚至上千）；\n元素极端倾斜（几乎全是 1，只有极少几个非 1 值）；\n并且非 1 的值集中在数组末尾，比如：[-5, -4, -3, -2, -1]。\n\n原地划分太难理解，采用额外空间划分：\nclass Solution &#123;public:    int quickSelect(vector&lt;int&gt;&amp; nums, int k) &#123;        int pivot = nums[rand()%nums.size()];        vector&lt;int&gt; small,big,equal;        for(int i=0;i&lt;nums.size();i++)&#123;            if(nums[i]&gt;pivot) big.push_back(nums[i]);            else if(nums[i]&lt;pivot) small.push_back(nums[i]);            else equal.push_back(nums[i]);        &#125;        if(k&lt;=big.size())            return quickSelect(big,k);        else if(nums.size()-small.size()&lt;k)            return quickSelect(small, k-nums.size()+small.size());        else return pivot;        return 0;    &#125;    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;        return quickSelect(nums, k);     &#125;&#125;;\n\n最小堆&#x2F;最大堆第k大问题也可以用堆来解决。\nC++中，优先队列priority_queue的底层是使用最大堆来实现的；\npriority_queue的基本语法：\n#include &lt;queue&gt;priority_queue&lt;int&gt; pq;  // 默认最大堆\n\n常用的操作：\n\n\n\n操作\n说明\n\n\n\npq.push(x);\n插入元素 x\n\n\npq.top();\n访问堆顶元素（最大&#x2F;最小）\n\n\npq.pop();\n删除堆顶元素\n\n\npq.empty();\n判断是否为空\n\n\npq.size();\n当前元素个数\n\n\npriority_queue默认是最大堆。如果是最小堆：\npriority_queue&lt;int, vector&lt;int&gt;, greater&lt;&gt;&gt; minHeap;\n\n其中：\n\nint表示存储的元素类型为int\nvector&lt;int&gt;表示底层存储方式\ngreater&lt;int&gt;()(a, b)返回 true表示 a &gt; b\n\n类似地，Java也使用PriorityQueue类来实现最小堆&#x2F;最大堆。\nimport java.util.PriorityQueue;PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;();\n\nPriorityQueue的常见操作：\n\n\n\n操作\n含义\n\n\n\nadd(x) &#x2F; offer(x)\n插入元素\n\n\npeek()\n查看堆顶（不移除）\n\n\npoll()\n弹出堆顶（并移除）\n\n\nsize() &#x2F; isEmpty()\n查看大小 &#x2F; 是否为空\n\n\n对于自定义的比较，需要重写Comparator\nPriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;((a, b) -&gt; b - a);\nLeetCode 347.前k个高频元素class Solution &#123;public:    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;        unordered_map&lt;int,int&gt; mymap;        for(int i=0;i&lt;nums.size();i++)&#123;            mymap[nums[i]]++;        &#125;        struct cmp&#123;            bool operator()(const pair&lt;int,int&gt;&amp;a,const pair&lt;int,int&gt;&amp; b)&#123;                return a.second&lt;b.second;//最大堆            &#125;        &#125;;        priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt;&gt;,cmp&gt; maxHeap;        for(auto p:mymap)&#123;            maxHeap.push(p);        &#125;        vector&lt;int&gt; res;        for(int i=0;i&lt;k;i++)&#123;            res.push_back(maxHeap.top().first);            maxHeap.pop();        &#125;        return res;    &#125;&#125;;\n\n这里自定义了一个最大堆，堆存储的元素为pair&lt;int,int&gt;。struct cmp是一个自定义的比较器，实现从小到大排列。\n","tags":["算法","堆","快速排序"]},{"title":"Hello World","url":"/2025/05/02/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"}]
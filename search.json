[{"title":"Hello World","url":"/2025/05/02/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"Top k问题 （快速选择&堆）","url":"/2025/05/03/Top%20k%E9%97%AE%E9%A2%98%20%EF%BC%88%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9&%E5%A0%86%EF%BC%89/","content":"快速排序思想（Quick Sort）\n选择一个“基准值”（pivot）。\n\n将数组划分为两部分：左边小于等于 pivot，右边大于 pivot。\n\n对左右两边递归地继续进行快速排序。\n\n\nvoid quickSort(vector&lt;int&gt;&amp; nums, int left, int right) &#123;    if (left &gt;= right) return;    int pivot = nums[right];    int i = left - 1;    for (int j = left; j &lt; right; ++j) &#123;        if (nums[j] &lt;= pivot) &#123;            ++i;            swap(nums[i], nums[j]);        &#125;    &#125;    swap(nums[i + 1], nums[right]); // 把 pivot 放到中间    quickSort(nums, left, i);    quickSort(nums, i + 2, right);&#125;\n\n快速选择思想（Quick Select）快排的核心思想在于递归的partition操作，通过一次partition操作可以保证pivot左边的元素小于于pivot，右边的元素大于pivot。在查找第 k 小（或第 k 大）元素问题中，partition与快速排序相似，但只递归一边。\nint partition(vector&lt;int&gt;&amp; nums, int left, int right) &#123;    int pivot = nums[right];           // 选取最后一个元素作为“基准”    int i = left;                      // i 表示 &lt;= pivot 的区域的右边界    for (int j = left; j &lt; right; ++j) &#123;        if (nums[j] &gt;= pivot) &#123;        // 保证左边是“大于等于 pivot”的数（因为我们找第 k 大）            swap(nums[i], nums[j]);    // 把当前 nums[j] 交换到 &lt;= pivot 区域的末尾            ++i;                       // 扩大该区域        &#125;    &#125;    swap(nums[i], nums[right]);        // 把 pivot 放到中间的位置（即第 i 位）    return i;                          // 返回 pivot 的最终位置&#125;int quickSelect(vector&lt;int&gt;&amp; nums, int left, int right, int k) &#123;    if (left &lt;= right) &#123;        int pos = partition(nums, left, right);  // 得到 pivot 的最终位置        if (pos == k) return nums[pos];          // 找到第 k 大的数（从 0 开始）        else if (pos &lt; k) return quickSelect(nums, pos + 1, right, k);  // 去右边找        else return quickSelect(nums, left, pos - 1, k);                // 去左边找    &#125;    return -1;  &#125;\n\nLeetCode 215.数组中第k大的元素给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。\n请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。\n你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。\nclass Solution &#123;public:    int partition(vector&lt;int&gt;&amp;nums, int left,int right)&#123;        int pivot = nums[right];        int i = left; //左边区域的右边界        // 把大于pivot的数放到左边        for(int j=left;j&lt;right;j++)&#123;            if(nums[j]&gt;=pivot)&#123;                swap(nums[i],nums[j]);//把nums[j]放到pivot左边的区域                i++;            &#125;        &#125;        swap(nums[i],nums[right]); // 把pivot放到中间的位置        return i;    &#125;    int quickSelect(vector&lt;int&gt;&amp;nums,int left,int right,int k)&#123;        if(left&lt;=right)&#123;            int pos = partition(nums,left,right);            if(pos == k) return nums[pos];            else if(pos&lt;k) return quickSelect(nums,pos+1,right,k);            else return quickSelect(nums,left,pos-1,k);        &#125;        return 0;    &#125;        int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;        int n = nums.size();        return quickSelect(nums,0,n-1,k-1);// 第k大元素的下标是k-1    &#125;&#125;;\n\n问题：超时。最坏情况下，时间复杂度到达O(n2)，输入的数组具有以下特征：\n\n非常长（几百个元素甚至上千）；\n元素极端倾斜（几乎全是 1，只有极少几个非 1 值）；\n并且非 1 的值集中在数组末尾，比如：[-5, -4, -3, -2, -1]。\n\n原地划分太难理解，采用额外空间划分：\nclass Solution &#123;public:    int quickSelect(vector&lt;int&gt;&amp; nums, int k) &#123;        int pivot = nums[rand()%nums.size()];        vector&lt;int&gt; small,big,equal;        for(int i=0;i&lt;nums.size();i++)&#123;            if(nums[i]&gt;pivot) big.push_back(nums[i]);            else if(nums[i]&lt;pivot) small.push_back(nums[i]);            else equal.push_back(nums[i]);        &#125;        if(k&lt;=big.size())            return quickSelect(big,k);        else if(nums.size()-small.size()&lt;k)            return quickSelect(small, k-nums.size()+small.size());        else return pivot;        return 0;    &#125;    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;        return quickSelect(nums, k);     &#125;&#125;;\n\n最小堆&#x2F;最大堆第k大问题也可以用堆来解决。\nC++中，优先队列priority_queue的底层是使用最大堆来实现的；\npriority_queue的基本语法：\n#include &lt;queue&gt;priority_queue&lt;int&gt; pq;  // 默认最大堆\n\n常用的操作：\n\n\n\n操作\n说明\n\n\n\npq.push(x);\n插入元素 x\n\n\npq.top();\n访问堆顶元素（最大&#x2F;最小）\n\n\npq.pop();\n删除堆顶元素\n\n\npq.empty();\n判断是否为空\n\n\npq.size();\n当前元素个数\n\n\npriority_queue默认是最大堆。如果是最小堆：\npriority_queue&lt;int, vector&lt;int&gt;, greater&lt;&gt;&gt; minHeap;\n\n其中：\n\nint表示存储的元素类型为int\nvector&lt;int&gt;表示底层存储方式\ngreater&lt;int&gt;()(a, b)返回 true表示 a &gt; b\n\n类似地，Java也使用PriorityQueue类来实现最小堆&#x2F;最大堆。\nimport java.util.PriorityQueue;PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;();\n\nPriorityQueue的常见操作：\n\n\n\n操作\n含义\n\n\n\nadd(x) &#x2F; offer(x)\n插入元素\n\n\npeek()\n查看堆顶（不移除）\n\n\npoll()\n弹出堆顶（并移除）\n\n\nsize() &#x2F; isEmpty()\n查看大小 &#x2F; 是否为空\n\n\n对于自定义的比较，需要重写Comparator\nPriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;((a, b) -&gt; b - a);\nLeetCode 347.前k个高频元素class Solution &#123;public:    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;        unordered_map&lt;int,int&gt; mymap;        for(int i=0;i&lt;nums.size();i++)&#123;            mymap[nums[i]]++;        &#125;        struct cmp&#123;            bool operator()(const pair&lt;int,int&gt;&amp;a,const pair&lt;int,int&gt;&amp; b)&#123;                return a.second&lt;b.second;//最大堆            &#125;        &#125;;        priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt;&gt;,cmp&gt; maxHeap;        for(auto p:mymap)&#123;            maxHeap.push(p);        &#125;        vector&lt;int&gt; res;        for(int i=0;i&lt;k;i++)&#123;            res.push_back(maxHeap.top().first);            maxHeap.pop();        &#125;        return res;    &#125;&#125;;\n\n这里自定义了一个最大堆，堆存储的元素为pair&lt;int,int&gt;。struct cmp是一个自定义的比较器，实现从小到大排列。\n","tags":["算法","堆","快速排序"]},{"title":"黑马头条D1","url":"/2025/05/03/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1D1/","content":"Nacos安装和配置我的Docker在本地跑不起来（？网上说是内存泄漏），这里在虚拟机使用Docker安装。虚拟机系统：CentOS7\n首先Docker拉取Nacos镜像：\ndocker pull nacos/nacos-server:1.2.0\n\n查看所有的镜像，检查Nacos镜像是否已经拉取成功：\ndocker images\n\n然后创建容器：\ndocker run --env MODE=standalone --name nacos --restart=always -d -p 8848:8848 nacos/nacos-server:1.2.0\n\n\nMODE&#x3D;standalone 单机版\n–restart&#x3D;always 开机启动\n-p 8848:8848 映射端口\n-d 创建一个守护式容器在后台运行\n\n使用命令列出所有的Docker容器\ndocker ps\n\ndocker查看日志：\ndocker logs -f &lt;容器id&gt;\n\nFinally，Nacos的访问地址：http://192.168.200.128:8848/nacos\n初始工程搭建异常处理机制导入工程后，首先定义异常处理。异常处理机制可以避免返回堆栈或者是错误的页面，也便于排查和日志记录。\n\ncommon模块下的exception包包含了两个异常类，CustomException是自定义的异常类，ExceptionCatch是对全局异常的拦截处理：\nCustomException:\npublic class CustomException extends RuntimeException &#123;    private AppHttpCodeEnum appHttpCodeEnum;    public CustomException(AppHttpCodeEnum appHttpCodeEnum)&#123;        this.appHttpCodeEnum = appHttpCodeEnum;    &#125;    public CustomException(AppHttpCodeEnum appHttpCodeEnum, String msg)&#123;        this.appHttpCodeEnum = appHttpCodeEnum;    &#125;    public AppHttpCodeEnum getAppHttpCodeEnum() &#123;        return appHttpCodeEnum;    &#125;&#125;\n\nExceptionCatch:\n@ControllerAdvice  //控制器增强类@Slf4jpublic class ExceptionCatch &#123;    /**     * 处理不可控异常     * @param e     * @return     */    @ExceptionHandler(Exception.class)    @ResponseBody    public ResponseResult exception(Exception e)&#123;        e.printStackTrace();        log.error(&quot;catch exception:&#123;&#125;&quot;,e.getMessage());        return ResponseResult.errorResult(AppHttpCodeEnum.SERVER_ERROR);    &#125;    /**     * 处理可控异常  自定义异常     * @param e     * @return     */    @ExceptionHandler(CustomException.class) //指定当前要拦截哪些异常    @ResponseBody    public ResponseResult exception(CustomException e)&#123;        log.error(&quot;catch exception:&#123;&#125;&quot;,e);        return ResponseResult.errorResult(e.getAppHttpCodeEnum());    &#125;&#125;\n\nSpring自动装配在common模块下的resource里有spring.factories文件，这个文件是Spring Boot提供的一种SPI(服务发现机制)。它的作用是在项目启动时自动加载指定的类。\n\n\n在spring.factories里指向刚才定义的ExceptionCatch：\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\  com.heima.common.exception.ExceptionCatch\n\n在项目启动时，Spring Boot 会自动加载并执行ExceptionCatch类，就像手动加载了@Configuration.\n登录模块创建用户实体类登录模块主要涉及用户表，也就是ap_user表：\n\n\nap_user表的结构如下：\n\n\n根据表结构，在model模块下的user包里面新建pojos包，新建一个ApUser类，与表的结构对应。\npackage com.heima.model.user.pojos;import com.baomidou.mybatisplus.annotation.IdType;import com.baomidou.mybatisplus.annotation.TableField;import com.baomidou.mybatisplus.annotation.TableId;import com.baomidou.mybatisplus.annotation.TableName;import lombok.Data;import java.io.Serializable;import java.util.Date; /** * &lt;p&gt; * APP用户信息表 * &lt;/p&gt; * * @author itheima */@Data@TableName(&quot;ap_user&quot;)public class ApUser implements Serializable &#123;     private static final long serialVersionUID = 1L;     /**     * 主键     */    @TableId(value = &quot;id&quot;, type = IdType.AUTO)    private Integer id;     /**     * 密码、通信等加密盐     */    @TableField(&quot;salt&quot;)    private String salt;     /**     * 用户名     */    @TableField(&quot;name&quot;)    private String name;     /**     * 密码,md5加密     */    @TableField(&quot;password&quot;)    private String password;     /**     * 手机号     */    @TableField(&quot;phone&quot;)    private String phone;     /**     * 头像     */    @TableField(&quot;image&quot;)    private String image;     /**     * 0 男            1 女            2 未知     */    @TableField(&quot;sex&quot;)    private Boolean sex;     /**     * 0 未            1 是     */    @TableField(&quot;is_certification&quot;)    private Boolean certification;     /**     * 是否身份认证     */    @TableField(&quot;is_identity_authentication&quot;)    private Boolean identityAuthentication;     /**     * 0正常            1锁定     */    @TableField(&quot;status&quot;)    private Boolean status;     /**     * 0 普通用户            1 自媒体人            2 大V     */    @TableField(&quot;flag&quot;)    private Short flag;     /**     * 注册时间     */    @TableField(&quot;created_time&quot;)    private Date createdTime; &#125;\n\n也可以使用MyBatis-Plus逆向生成实体类。\n\n添加MyBatis-Plus依赖\n&lt;dependency&gt;  &lt;groupId&gt;com.baomidou&lt;/groupId&gt;  &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;  &lt;version&gt;3.5.5&lt;/version&gt;&lt;/dependency&gt;\n\n在application.yaml中配置数据库连接\nspring:  datasource:    url: jdbc:mysql://localhost:3306/leadnews_user?useSSL=false&amp;serverTimezone=Asia/Shanghai    username: root    password: 123456    driver-class-name: com.mysql.cj.jdbc.Driver\n\n添加代码生成器依赖\n&lt;dependency&gt;  &lt;groupId&gt;com.baomidou&lt;/groupId&gt;  &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;  &lt;version&gt;3.5.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt;  &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt;  &lt;version&gt;2.3&lt;/version&gt;&lt;/dependency&gt;\n\n创建CodeGenerator.java工具类\nimport com.baomidou.mybatisplus.generator.AutoGenerator;import com.baomidou.mybatisplus.generator.config.*;import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;public class CodeGenerator &#123;    public static void main(String[] args) &#123;        // 1. 代码生成器        AutoGenerator mpg = new AutoGenerator();        // 2. 数据源配置        DataSourceConfig dsc = new DataSourceConfig();        dsc.setUrl(&quot;jdbc:mysql://localhost:3306/your_db?useSSL=false&amp;serverTimezone=Asia/Shanghai&quot;);        dsc.setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;);        dsc.setUsername(&quot;root&quot;);        dsc.setPassword(&quot;123456&quot;);        mpg.setDataSource(dsc);        // 3. 全局配置        GlobalConfig gc = new GlobalConfig();        gc.setOutputDir(System.getProperty(&quot;user.dir&quot;) + &quot;/src/main/java&quot;);        gc.setAuthor(&quot;Ant&quot;);        gc.setOpen(false);        gc.setSwagger2(false);        gc.setBaseResultMap(true);        gc.setBaseColumnList(true);        mpg.setGlobalConfig(gc);        // 4. 包配置        PackageConfig pc = new PackageConfig();        pc.setParent(&quot;com.heima.leadnews-model&quot;);        pc.setEntity(&quot;entity&quot;);        pc.setMapper(&quot;mapper&quot;);        pc.setXml(&quot;mapper.xml&quot;);        pc.setService(&quot;service&quot;);        pc.setServiceImpl(&quot;service.impl&quot;);        mpg.setPackageInfo(pc);        // 5. 策略配置        StrategyConfig strategy = new StrategyConfig();        strategy.setInclude(&quot;ap_user&quot;); // 要生成的表名        strategy.setNaming(NamingStrategy.underline_to_camel); // 表映射到实体的命名策略        strategy.setColumnNaming(NamingStrategy.underline_to_camel);        strategy.setEntityLombokModel(true); // 使用 Lombok        strategy.setRestControllerStyle(true); // 使用 @RestController        mpg.setStrategy(strategy);        // 6. 执行生成        mpg.execute();    &#125;&#125;\n\n运行CodeGenerator，将生成：\n\nApUser实体类\nMapper接口 \nMapper映射文件\n\n\n\n手动加盐手动加盐的过程\n\n\n用户端服务搭建service模块下的pom文件:\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;com.heima&lt;/groupId&gt;        &lt;artifactId&gt;leadnews&lt;/artifactId&gt;        &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;/parent&gt;    &lt;modules&gt;        &lt;module&gt;leadnews-user&lt;/module&gt;        &lt;module&gt;leadnews-article&lt;/module&gt;        &lt;module&gt;leadnews-wemedia&lt;/module&gt;        &lt;module&gt;leadnews-schedule&lt;/module&gt;        &lt;module&gt;leadnews-search&lt;/module&gt;        &lt;module&gt;leadnews-admin&lt;/module&gt;        &lt;module&gt;leadnews-behavior&lt;/module&gt;    &lt;/modules&gt;    &lt;artifactId&gt;leadnews-service&lt;/artifactId&gt;    &lt;packaging&gt;pom&lt;/packaging&gt;    &lt;properties&gt;        &lt;maven.compiler.source&gt;18&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;18&lt;/maven.compiler.target&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;jmu.lsk&lt;/groupId&gt;            &lt;artifactId&gt;leadnews-model&lt;/artifactId&gt;            &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;jmu.lsk&lt;/groupId&gt;            &lt;artifactId&gt;leadnews-utils&lt;/artifactId&gt;            &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;jmu.lsk&lt;/groupId&gt;            &lt;artifactId&gt;leadnews-common&lt;/artifactId&gt;            &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;jmu.lsk&lt;/groupId&gt;            &lt;artifactId&gt;leadnews-feign-api&lt;/artifactId&gt;            &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt;            &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt;            &lt;version&gt;2.3.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;io.minio&lt;/groupId&gt;            &lt;artifactId&gt;minio&lt;/artifactId&gt;            &lt;version&gt;8.5.9&lt;/version&gt;            &lt;exclusions&gt;                &lt;exclusion&gt;                    &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt;                    &lt;artifactId&gt;okhttp&lt;/artifactId&gt;                &lt;/exclusion&gt;            &lt;/exclusions&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;            &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;            &lt;exclusions&gt;                &lt;exclusion&gt;                    &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;                    &lt;artifactId&gt;kafka-clients&lt;/artifactId&gt;                &lt;/exclusion&gt;            &lt;/exclusions&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;            &lt;artifactId&gt;kafka-clients&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt;            &lt;artifactId&gt;okhttp&lt;/artifactId&gt;            &lt;version&gt;4.11.0&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;\n\n在leadnews-service下新建leadnews-user模块，选中parent为leadnews-service，然后创建一个启动类UserApplication.\n@SpringBootApplication@EnableDiscoveryClient@MapperScan(&quot;com.heima.user.mapper&quot;)public class UserApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(UserApplication.class,args);    &#125;&#125;\n\nresource文件夹下bootstrap.yml\nserver:  port: 51801spring:  application:    name: leadnews-user  cloud:    nacos:      discovery:        enabled: true        server-addr: 192.168.200.128:8848        register-enabled: true        username: nacos        password: nacos        namespace: public        group: DEFAULT_GROUP        ephemeral: true        weight: 100      config:        server-addr: $&#123;spring.cloud.nacos.discovery.server-addr&#125;        username: $&#123;spring.cloud.nacos.discovery.username&#125;        password: $&#123;spring.cloud.nacos.discovery.password&#125;        namespace: $&#123;spring.cloud.nacos.discovery.namespace&#125;        file-extension: yaml        group: DEFAULT_GROUP        context-path: /nacos\n\nNacos新增配置\n访问http://192.168.200.128:8848/nacos的时候出现了问题，主要两个原因：\n\n没有为虚拟机分配IP地址\n解决方法：设置静态地址&#x2F;使用DHCP分配（注意：之前设置了NAT）\n\nCentOS 启用了 SELinux，阻止 Docker 监听外部端口\n解决方法：把SELinux关掉，编辑配置文件：\nsudo vi /etc/selinux/config\n\n将SELINUX设置为disabled，然后重启系统。\n\n\n\nspring:  datasource:    driver-class-name: com.mysql.jdbc.Driver    url: jdbc:mysql://localhost:3306/leadnews_user?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC    username: root    password: 123456# 设置Mapper接口所对应的XML文件位置，如果你在Mapper接口中有自定义方法，需要进行该配置mybatis-plus:  mapper-locations: classpath*:mapper/*.xml  # 设置别名包扫描路径，通过该属性可以给包中的类注册别名  type-aliases-package: com.heima.model.user.pojos\n\n\n\n为什么要使用Nacos？\n使用Nacos集中管理微服务项目的配置文件，防止配置散落在各个模块的application.yml中\n修改Nacos配置之后，微服务可以实时感知\n多个微服务可以共享配置，避免重复定义\n通过Namespace和Group功能实现环境隔离\n\nlogback.xmllogback.xml 文件是 Logback 日志框架的配置文件，用于定义应用程序的日志输出行为。\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration&gt;    &lt;!--定义日志文件的存储地址,使用绝对路径--&gt;    &lt;property name=&quot;LOG_HOME&quot; value=&quot;g:/logs&quot;/&gt;    &lt;!-- Console 输出设置 --&gt;    &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;        &lt;encoder&gt;            &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt;            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt;            &lt;charset&gt;utf8&lt;/charset&gt;        &lt;/encoder&gt;    &lt;/appender&gt;    &lt;!-- 按照每天生成日志文件 --&gt;    &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;            &lt;!--日志文件输出的文件名--&gt;            &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;/leadnews.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;        &lt;/rollingPolicy&gt;        &lt;encoder&gt;            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt;        &lt;/encoder&gt;    &lt;/appender&gt;    &lt;!-- 异步输出 --&gt;    &lt;appender name=&quot;ASYNC&quot; class=&quot;ch.qos.logback.classic.AsyncAppender&quot;&gt;        &lt;!-- 不丢失日志.默认的,如果队列的80%已满,则会丢弃TRACT、DEBUG、INFO级别的日志 --&gt;        &lt;discardingThreshold&gt;0&lt;/discardingThreshold&gt;        &lt;!-- 更改默认的队列的深度,该值会影响性能.默认值为256 --&gt;        &lt;queueSize&gt;512&lt;/queueSize&gt;        &lt;!-- 添加附加的appender,最多只能添加一个 --&gt;        &lt;appender-ref ref=&quot;FILE&quot;/&gt;    &lt;/appender&gt;    &lt;logger name=&quot;org.apache.ibatis.cache.decorators.LoggingCache&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt;        &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;    &lt;/logger&gt;    &lt;logger name=&quot;org.springframework.boot&quot; level=&quot;debug&quot;/&gt;    &lt;root level=&quot;info&quot;&gt;        &lt;!--&lt;appender-ref ref=&quot;ASYNC&quot;/&gt;--&gt;        &lt;appender-ref ref=&quot;FILE&quot;/&gt;        &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;    &lt;/root&gt;&lt;/configuration&gt;\n\napp登录接口\n\n\n\n说明\n\n\n\n接口路径\n&#x2F;api&#x2F;v1&#x2F;login&#x2F;login_auth\n\n\n请求方式\nPOST\n\n\n参数\nLoginDto\n\n\n响应结果\nResponseResult\n\n\n定义ResponseResult首先，在leadnews-model模块下的common&#x2F;dtos包中，定义一个通用的结果类ResponseResult.java\npublic class ResponseResult&lt;T&gt; implements Serializable &#123;    private String host;    private Integer code;    private String errorMessage;    private T data;    public ResponseResult() &#123;        this.code = 200;    &#125;    public ResponseResult(Integer code, T data) &#123;        this.code = code;        this.data = data;    &#125;    public ResponseResult(Integer code, String msg, T data) &#123;        this.code = code;        this.errorMessage = msg;        this.data = data;    &#125;    public ResponseResult(Integer code, String msg) &#123;        this.code = code;        this.errorMessage = msg;    &#125;    public static ResponseResult errorResult(int code, String msg) &#123;        ResponseResult result = new ResponseResult();        return result.error(code, msg);    &#125;    public static ResponseResult okResult(int code, String msg) &#123;        ResponseResult result = new ResponseResult();        return result.ok(code, null, msg);    &#125;    public static ResponseResult okResult(Object data) &#123;        ResponseResult result = setAppHttpCodeEnum(AppHttpCodeEnum.SUCCESS, AppHttpCodeEnum.SUCCESS.getErrorMessage());        if(data!=null) &#123;            result.setData(data);        &#125;        return result;    &#125;    public static ResponseResult errorResult(AppHttpCodeEnum enums)&#123;        return setAppHttpCodeEnum(enums,enums.getErrorMessage());    &#125;    public static ResponseResult errorResult(AppHttpCodeEnum enums, String errorMessage)&#123;        return setAppHttpCodeEnum(enums,errorMessage);    &#125;    public static ResponseResult setAppHttpCodeEnum(AppHttpCodeEnum enums)&#123;        return okResult(enums.getCode(),enums.getErrorMessage());    &#125;    private static ResponseResult setAppHttpCodeEnum(AppHttpCodeEnum enums, String errorMessage)&#123;        return okResult(enums.getCode(),errorMessage);    &#125;    public ResponseResult&lt;?&gt; error(Integer code, String msg) &#123;        this.code = code;        this.errorMessage = msg;        return this;    &#125;    public ResponseResult&lt;?&gt; ok(Integer code, T data) &#123;        this.code = code;        this.data = data;        return this;    &#125;    public ResponseResult&lt;?&gt; ok(Integer code, T data, String msg) &#123;        this.code = code;        this.data = data;        this.errorMessage = msg;        return this;    &#125;    public ResponseResult&lt;?&gt; ok(T data) &#123;        this.data = data;        return this;    &#125;    public Integer getCode() &#123;        return code;    &#125;    public void setCode(Integer code) &#123;        this.code = code;    &#125;    public String getErrorMessage() &#123;        return errorMessage;    &#125;    public void setErrorMessage(String errorMessage) &#123;        this.errorMessage = errorMessage;    &#125;    public T getData() &#123;        return data;    &#125;    public void setData(T data) &#123;        this.data = data;    &#125;    public String getHost() &#123;        return host;    &#125;    public void setHost(String host) &#123;        this.host = host;    &#125;    public static void main(String[] args) &#123;        //前置        /*AppHttpCodeEnum success = AppHttpCodeEnum.SUCCESS;        System.out.println(success.getCode());        System.out.println(success.getErrorMessage());*/        //查询一个对象        /*Map map = new HashMap();        map.put(&quot;name&quot;,&quot;zhangsan&quot;);        map.put(&quot;age&quot;,18);        ResponseResult result = ResponseResult.okResult(map);        System.out.println(JSON.toJSONString(result));*/        //新增，修改，删除  在项目中统一返回成功即可       /* ResponseResult result = ResponseResult.errorResult(AppHttpCodeEnum.SUCCESS);        System.out.println(JSON.toJSONString(result));*/        //根据不用的业务返回不同的提示信息  比如：当前操作需要登录、参数错误        /*ResponseResult result = ResponseResult.errorResult(AppHttpCodeEnum.NEED_LOGIN);        System.out.println(JSON.toJSONString(result));*/        //查询分页信息        PageResponseResult responseResult = new PageResponseResult(1,5,50);        List list = new ArrayList();        list.add(&quot;itcast&quot;);        list.add(&quot;itheima&quot;);        responseResult.setData(list);        System.out.println(JSON.toJSONString(responseResult));    &#125;&#125;\n\n用户登录的具体实现ApUserLoginController:\n@RestController@RequestMapping(&quot;/api/v1/login&quot;)@Tag(name = &quot;app端用户登录&quot;,description = &quot;app端用户登录API&quot;)public class ApUserLoginController &#123;    @Autowired    private ApUserService apUserService;    @PostMapping(&quot;/login_auth&quot;)    @Operation(summary = &quot;用户登录&quot;)    public ResponseResult login(LoginDto dto)&#123;        return apUserService.login(dto);    &#125;&#125;\n\nApUserMapper:\n@Mapperpublic interface ApUserMapper extends BaseMapper&lt;ApUser&gt; &#123;&#125;\n\nApUserService:\npublic interface ApUserService extends IService&lt;ApUser&gt; &#123;     /**     * app端登录     * @param dto     * @return     */    public ResponseResult login(LoginDto dto);    &#125;\n\nApUserServiceImpl: （在实现类按ctrl+i，勾选copy JavaDoc，快速实现接口。）\n登录的流程：\n\n\n@Servicepublic class ApUserServiceImpl extends ServiceImpl&lt;ApUserMapper, ApUser&gt; implements ApUserService &#123;    @Override    public ResponseResult login(LoginDto dto) &#123;            dto.setPhone(&quot;12345678910&quot;);            dto.setPassword(&quot;123456&quot;);            //1.正常登录（手机号+密码登录）            if (!StringUtils.isBlank(dto.getPhone()) &amp;&amp; !StringUtils.isBlank(dto.getPassword())) &#123;                //1.1查询用户                ApUser apUser = getOne(Wrappers.&lt;ApUser&gt;lambdaQuery().eq(ApUser::getPhone, dto.getPhone()));                if (apUser == null) &#123;                    return ResponseResult.errorResult(AppHttpCodeEnum.DATA_NOT_EXIST,&quot;用户不存在&quot;);                &#125;                //1.2 比对密码                String salt = apUser.getSalt();                String pswd = dto.getPassword();                pswd = DigestUtils.md5DigestAsHex((pswd + salt).getBytes());                if (!pswd.equals(apUser.getPassword())) &#123;                    return ResponseResult.errorResult(AppHttpCodeEnum.LOGIN_PASSWORD_ERROR);                &#125;                //1.3 返回数据  jwt                Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();                map.put(&quot;token&quot;, AppJwtUtil.getToken(apUser.getId().longValue()));                //这两个值 置空 再返回对象                apUser.setSalt(&quot;&quot;);                apUser.setPassword(&quot;&quot;);                map.put(&quot;user&quot;, apUser);                return ResponseResult.okResult(map);            &#125;            else &#123;                //2.游客  同样返回token  id = 0                Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();                map.put(&quot;token&quot;, AppJwtUtil.getToken(0l));                return ResponseResult.okResult(map);            &#125;        &#125;    &#125;\n\nDebug模式启动UserApplication，遇到问题：不支持发行版本 18，解决方法：将pom.xml中的版本修改为17.\n这里一直启动不起来，拉取不到Nacos配置 ，替换成本地application.yaml的时候可以启动。\n暂时先使用本地配置了，nacos的问题到后面再解决。\nPostman测试","tags":["项目","Nacos"]}]